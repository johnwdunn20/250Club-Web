---
alwaysApply: true
---

# 250 Club Core Development Rules

## UI Components: Always Prefer shadcn/ui

**IMPORTANT: Always use shadcn/ui components when possible.** Before creating custom UI elements, check if a shadcn/ui component exists.

### Adding New shadcn/ui Components

If you need a component not yet installed, add it with:

```bash
pnpm dlx shadcn@latest add <component-name>
```

Common components to consider: `input`, `label`, `select`, `checkbox`, `radio-group`, `switch`, `textarea`, `avatar`, `dropdown-menu`, `sheet`, `tooltip`, `progress`, `separator`

### Component Usage Patterns

```tsx
// Always import from @/components/ui/
import { Button } from "@/components/ui/button"
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card"

// Use cn() for conditional classes
import { cn } from "@/lib/utils"

<Button className={cn("w-full", isLoading && "opacity-50")} disabled={isLoading}>
  {isLoading ? "Loading..." : "Submit"}
</Button>
```

## Convex: Project-Specific Patterns

### Authentication in Convex Functions

**ALWAYS use `getCurrentUser(ctx)` from `convex/utils.ts`** for authenticated functions:

```typescript
import { getCurrentUser } from "./utils"

export const myFunction = query({
  args: {},
  returns: v.null(),
  handler: async (ctx) => {
    const user = await getCurrentUser(ctx) // Handles auth check + user lookup
    // user is guaranteed to exist here
    return null
  },
})
```

### Database Schema Reference

Key tables in this project (`convex/schema.ts`):

- `users` - Synced from Clerk via `tokenIdentifier`
- `friendships` - Bidirectional friend relationships
- `friend_requests` - Pending friendship invitations
- `challenges` - Daily fitness challenges with date (YYYY-MM-DD)
- `exercises` - Individual exercises within challenges
- `challenge_participants` - User participation in challenges
- `exercise_progress` - Reps completed per user per exercise
- `notifications` - User notifications

### Function Structure

Always include `args` and `returns` validators:

```typescript
import { query, mutation } from "./_generated/server"
import { v } from "convex/values"

export const myQuery = query({
  args: {
    timezone: v.string(),
  },
  returns: v.union(
    v.object({
      _id: v.id("challenges"),
      name: v.string(),
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    const user = await getCurrentUser(ctx)
    // Implementation
    return null
  },
})
```

## React Component Patterns

### Convex Hooks

```tsx
"use client"

import { useQuery, useMutation } from "convex/react"
import { api } from "../../convex/_generated/api"

function MyComponent() {
  // Queries - pass timezone for date-specific data
  const challenge = useQuery(api.challenges.getTodaysChallenge, {
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
  })

  // Mutations
  const createChallenge = useMutation(api.challenges.createChallenge)

  // Handle loading state with skeletons
  if (challenge === undefined) {
    return <ChallengeSkeleton />
  }
}
```

### Loading States

Use skeleton components from `src/components/skeletons/`:

```tsx
import { DashboardSkeleton } from "@/components/skeletons/DashboardSkeleton"

if (data === undefined) {
  return <DashboardSkeleton />
}
```

### Convex Query States: `undefined` vs `null`

**CRITICAL: Never coerce Convex query results with `|| undefined` or `|| null`.**

Convex `useQuery` returns three distinct states:

| State | Value | Meaning |
|-------|-------|---------|
| Loading | `undefined` | Query hasn't returned yet |
| No data | `null` | Query completed, no results found |
| Has data | `[...]` or `{...}` | Query completed with data |

**WRONG - conflates loading and no-data:**

```tsx
// BAD: || treats both null and undefined as falsy
<MyComponent data={queryResult || undefined} />

// BAD: This makes "no data" look like "still loading"
if (data === undefined) return <Skeleton />  // Will show skeleton for null too!
```

**CORRECT - handle all three states explicitly:**

```tsx
// GOOD: Pass query result directly, accept null in prop types
interface Props {
  data: MyData[] | null | undefined  // Accept all three states
}

// GOOD: Handle states explicitly in component
if (data === undefined) {
  return <Skeleton />  // Loading
}
if (data === null || data.length === 0) {
  return <EmptyState />  // No data
}
return <DataView data={data} />  // Has data
```

When passing Convex query results as props:
1. **Never coerce** - pass the value directly
2. **Type props to accept `| null | undefined`** - forces explicit handling
3. **Check `=== undefined` for loading** - not falsy checks
4. **Check `=== null` for no-data** - distinct from loading