---
alwaysApply: true
---

# 250 Club Core Development Rules

## UI Components: Always Prefer shadcn/ui

**IMPORTANT: Always use shadcn/ui components when possible.** Before creating custom UI elements, check if a shadcn/ui component exists.

### Adding New shadcn/ui Components

If you need a component not yet installed, add it with:

```bash
pnpm dlx shadcn@latest add <component-name>
```

Common components to consider: `input`, `label`, `select`, `checkbox`, `radio-group`, `switch`, `textarea`, `avatar`, `dropdown-menu`, `sheet`, `tooltip`, `progress`, `separator`

### Component Usage Patterns

```tsx
// Always import from @/components/ui/
import { Button } from "@/components/ui/button"
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card"

// Use cn() for conditional classes
import { cn } from "@/lib/utils"

;<Button
  className={cn("w-full", isLoading && "opacity-50")}
  disabled={isLoading}
>
  {isLoading ? "Loading..." : "Submit"}
</Button>
```

## Convex: Project-Specific Patterns

### Authentication in Convex Functions

**ALWAYS use `getCurrentUser(ctx)` from `convex/utils.ts`** for authenticated functions:

```typescript
import { getCurrentUser } from "./utils"

export const myFunction = query({
  args: {},
  returns: v.null(),
  handler: async ctx => {
    const user = await getCurrentUser(ctx) // Handles auth check + user lookup
    // user is guaranteed to exist here
    return null
  },
})
```

### Database Schema Reference

Key tables in this project (`convex/schema.ts`):

- `users` - Synced from Clerk via `tokenIdentifier`
- `friendships` - Bidirectional friend relationships
- `friend_requests` - Pending friendship invitations
- `challenges` - Daily fitness challenges with date (YYYY-MM-DD)
- `exercises` - Individual exercises within challenges
- `challenge_participants` - User participation in challenges
- `exercise_progress` - Reps completed per user per exercise
- `notifications` - User notifications

### Function Structure

Always include `args` and `returns` validators:

```typescript
import { query, mutation } from "./_generated/server"
import { v } from "convex/values"

export const myQuery = query({
  args: {
    timezone: v.string(),
  },
  returns: v.union(
    v.object({
      _id: v.id("challenges"),
      name: v.string(),
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    const user = await getCurrentUser(ctx)
    // Implementation
    return null
  },
})
```

## React Component Patterns

### Convex Hooks

```tsx
"use client"

import { useQuery, useMutation } from "convex/react"
import { api } from "../../convex/_generated/api"

function MyComponent() {
  // Queries - pass timezone for date-specific data
  const challenge = useQuery(api.challenges.getTodaysChallenge, {
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
  })

  // Mutations
  const createChallenge = useMutation(api.challenges.createChallenge)

  // Handle loading state with skeletons
  if (challenge === undefined) {
    return <ChallengeSkeleton />
  }
}
```

### Loading States

Use skeleton components from `src/components/skeletons/`:

```tsx
import { DashboardSkeleton } from "@/components/skeletons/DashboardSkeleton"

if (data === undefined) {
  return <DashboardSkeleton />
}
```

### Convex Query States: `undefined` vs `null`

**CRITICAL: Never coerce Convex query results with `|| undefined` or `|| null`.**

Convex `useQuery` returns three distinct states:

| State    | Value              | Meaning                           |
| -------- | ------------------ | --------------------------------- |
| Loading  | `undefined`        | Query hasn't returned yet         |
| No data  | `null`             | Query completed, no results found |
| Has data | `[...]` or `{...}` | Query completed with data         |

**WRONG - conflates loading and no-data:**

```tsx
// BAD: || treats both null and undefined as falsy
;<MyComponent data={queryResult || undefined} />

// BAD: This makes "no data" look like "still loading"
if (data === undefined) return <Skeleton /> // Will show skeleton for null too!
```

**CORRECT - handle all three states explicitly:**

```tsx
// GOOD: Pass query result directly, accept null in prop types
interface Props {
  data: MyData[] | null | undefined // Accept all three states
}

// GOOD: Handle states explicitly in component
if (data === undefined) {
  return <Skeleton /> // Loading
}
if (data === null || data.length === 0) {
  return <EmptyState /> // No data
}
return <DataView data={data} /> // Has data
```

When passing Convex query results as props:

1. **Never coerce** - pass the value directly
2. **Type props to accept `| null | undefined`** - forces explicit handling
3. **Check `=== undefined` for loading** - not falsy checks
4. **Check `=== null` for no-data** - distinct from loading

## Best Practices

### Complex Conditional Classes

For complex conditional styling, use helper functions instead of nested ternaries:

```tsx
// BAD: Hard to read and maintain
className={`base ${condition1 ? "a" : condition2 ? "b" : condition3 ? "c" : "d"}`}

// GOOD: Extract to helper function
function getStatusClasses(item: Item): string {
  if (item.isCompleted) return "bg-green-500 text-white"
  if (item.isPending) return "bg-yellow-500 text-black"
  if (item.isError) return "bg-red-500 text-white"
  return "bg-muted text-muted-foreground"
}

// Usage
className={`base ${getStatusClasses(item)}`}
```

### Performance in Loops

Never calculate expensive values inside `.map()` or render loops:

```tsx
// BAD: Calculated N times per render
{items.map(item => {
  const today = new Date().toISOString().split("T")[0]
  return <div>{item.date === today && "Today"}</div>
})}

// GOOD: Calculated once before loop
const today = getTodayDate()
{items.map(item => (
  <div>{item.date === today && "Today"}</div>
))}
```

### Loading States: Always Show Skeletons

**Never return `null` for loading states.** Always show a skeleton that matches the content layout:

```tsx
// BAD: Causes layout shift, poor UX
if (data === undefined) return null

// GOOD: Maintains layout, shows loading feedback
if (data === undefined) {
  return (
    <div className="card-mobile">
      <Skeleton className="h-8 w-48 mb-4" />
      <Skeleton className="h-4 w-full mb-2" />
      <Skeleton className="h-4 w-3/4" />
    </div>
  )
}
```

### Accessibility for Custom Components

When building custom interactive elements (progress bars, counters, etc.), add proper ARIA attributes:

```tsx
// Custom progress bar
<div
  role="progressbar"
  aria-valuenow={percentage}
  aria-valuemin={0}
  aria-valuemax={100}
  aria-label="Challenge progress"
  className="h-3 bg-muted rounded-full overflow-hidden"
>
  <div style={{ width: `${percentage}%` }} />
</div>
```
